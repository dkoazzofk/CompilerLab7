# Лабораторная работа 7: Преобразование и анализ кода с использованием Clang и LLVM

## Цель работы
Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

## Ход работы

### 1. Установка и подготовка среды
Установлены следующие инструменты в среде Ubuntu 22.04:
- `clang` — компилятор языка C/C++;
- `llvm` — инструменты анализа и оптимизации кода;
- `opt` — инструмент для работы с LLVM IR и применения оптимизаций;
- `Graphviz` — инструмент для визуализации кода.

**Команда для установки:**
```bash
sudo apt install clang llvm graphviz
```
![Установка_CLANG](https://github.com/user-attachments/assets/09f5fa7d-45b6-4d48-8a13-7450ee8c7941)
![Установка_Graphviz](https://github.com/user-attachments/assets/a3fb693d-9dd8-476d-b79c-d96bfba59c93)

### 2. Исходный код
```
#include <stdio.h>

int square(int x) { 
    return x * x; 
}

int main() {
    int a = 5;
    int b = square(a); 
    printf("%d\n", b); 
    return 0;
}
```

### 3. Получение AST

**Ключевые элементы вывода:**

- Узел `FunctionDecl` для square с параметром x.

- Узел `BinaryOperator` для операции x * x.

- Узел `CallExpr` для вызова square(a) в функции main.

Вывод:
AST точно отражает структуру программы, включая объявления функций и операций.

![clang](https://github.com/user-attachments/assets/d42d86c5-5b77-4898-9062-b3f385dd89d7)


### 4. Генерация LLVM IR
Команда:
```bash
clang -S -emit-llvm main.c -o main.ll
```
**Содержимое `main.ll`:**

![llvm](https://github.com/user-attachments/assets/edc1530b-46b1-4360-9d29-fd5d40edd4a0)


### 5. Оптимизация IR
**Шаг 1: Генерация неоптимизированного IR (O0):**
```bash
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```

**Шаг 2: Генерация оптимизированного IR (O2):**
```bash
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```

**Сравнение (diff):**
```bash
diff main_O0.ll main_O2.ll
```

**Изменения после оптимизации:**
- Функция `square` встроена в `main` (оптимизация -inline).

- Константа 25 подставлена напрямую (оптимизация -constprop).

- Удалены `alloca`, `load`, `store` (оптимизация -mem2reg).

**Вывод:**
Оптимизации значительно упростили код, устранив избыточные операции.

![IR](https://github.com/user-attachments/assets/341a5297-052e-4b41-b1d1-e8a5189ae953)

![IR_O2](https://github.com/user-attachments/assets/22a3079c-fd9d-4f2b-a653-5ea5818e092c)

![Сравнение](https://github.com/user-attachments/assets/b40fed9f-bd03-460f-8664-2eeaa8cbac59)


### 6. Граф потока управления программы
**Шаг 1: Генерация CFG:**

```bash
opt -passes=dot-cfg -disable-output main.ll
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```

**Шаг 2: Визуализация:**
```bash
xdg-open cfg_main.png
xdg-open cfg_square.png
```

**Результат:**

- Граф для `main` содержит один блок (после оптимизации).

- Граф для `square` показывает блок с операцией `mul`.

**Вывод:**
CFG наглядно демонстрирует упрощение потока управления после оптимизаций.

![opt](https://github.com/user-attachments/assets/295dc152-e66f-4779-965f-a17394a038f7)

![Преобразование](https://github.com/user-attachments/assets/ceb859b9-0fc0-4356-bf41-3139aa6100df)

## Выводы по работе
- Clang предоставляет мощные инструменты для анализа кода через AST и IR.

- Оптимизации LLVM (-O2) радикально упрощают IR, удаляя избыточные операции.

- CFG помогает визуализировать логику программы, что полезно для отладки и оптимизации.

# Ответы на контрольные вопросы

## 1. Что такое Clang, и какова его роль в процессе компиляции программ?
**Clang** — это фронтенд-компилятор для языков C, C++ и Objective-C, разработанный как часть проекта LLVM. Его основные функции:
- Лексический, синтаксический и семантический анализ исходного кода
- Генерация абстрактного синтаксического дерева (AST)
- Преобразование AST в промежуточное представление LLVM IR
- Интеграция с инструментами статического анализа

Роль: Clang выступает "переводчиком" между исходным кодом и LLVM IR, подготавливая программу для дальнейших этапов компиляции.

---

## 2. Что представляет собой LLVM и как он используется в современных компиляторах?
**LLVM** (Low Level Virtual Machine) — это инфраструктура для создания компиляторов, включающая:
- Модульную систему оптимизаций
- Генератор машинного кода для различных архитектур
- Универсальное промежуточное представление (IR)

Использование:
1. В компиляторах (Rust, Swift используют LLVM как бекенд)
2. Для JIT-компиляции (например, в Julia)
3. В инструментах статического анализа (Clang Static Analyzer)

Пример: Apple использует LLVM в компиляторе Swift для кросс-платформенной поддержки.

---

## 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

| Характеристика       | AST                          | LLVM IR                     |
|----------------------|------------------------------|-----------------------------|
| Уровень абстракции   | Высокоуровневое              | Низкоуровневое              |
| Зависимость от языка | Специфично для C/C++         | Языко-независимое           |
| Структура           | Дерево с узлами операторов   | Линейные инструкции в SSA   |
| Использование       | Для анализа кода             | Для оптимизаций и кодогенерации |

Пример: В AST оператор `a + b * c` сохраняет древовидную структуру, а в IR преобразуется в последовательность `%1 = mul, %2 = add`.

---

## 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
Основные цели IR:
1. **Разделение фронтенда и бекенда**: Позволяет поддерживать новые языки без изменения оптимизатора
2. **Унификация оптимизаций**: Одни и те же оптимизации работают для разных языков
3. **Анализ кода**: Упрощает статический анализ и верификацию
4. **Поддержка различных целевых платформ**: Генерация машинного кода из одного IR для x86, ARM и др.

Пример: Clang преобразует C++ в IR, а затем LLVM генерирует код для ARM и x86 из одного IR.

---

## 5. Что делает инструкция `alloca` в LLVM IR, и зачем она используется в функциях?
Инструкция `alloca`:
- Выделяет память в стеке кадра функции
- Возвращает указатель на выделенную область
- Автоматически освобождается при выходе из функции

Использование:
```llvm
%x = alloca i32  ; Выделение 4 байт в стеке
store i32 5, i32* %x  ; Запись значения
%val = load i32, i32* %x  ; Чтение
```
Зачем нужно: Для работы с локальными переменными до применения оптимизации `mem2reg`.

---

## 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Цели оптимизации:
1. Ускорение выполнения (пример: замена деления на степень двойки сдвигом).
2. Уменьшение размера кода (удаление мертвого кода)
3. Снижение энергопотребления (оптимизация циклов)
4. Улучшение предсказания ветвлений (разворот циклов)

Пример: Оптимизация -O2 в LLVM:

- Встраивание функций (inline)
- Распространение констант (constprop)
- Удаление общих подвыражений (gvn)

---

## 7. Что такое SSA-форма и почему она важна при оптимизации программ?

**SSA-форма** (Static Single Assignment) - это особый способ представления кода, при котором:
- Каждая переменная назначается **только один раз**
- Для слияния значений в точках ветвления используются φ-функции (phi-функции)

### Основные характеристики SSA:
1. **Уникальность определений**:
   ```llvm
   ; Не-SSA форма          ; SSA-форма
   %x = add i32 %a, 1      %x1 = add i32 %a, 1
   %x = mul i32 %x, 2      %x2 = mul i32 %x1, 2
   ```
2. Преимущества:
- Упрощает анализ зависимостей данных
- Позволяет применять оптимизации типа:
  1. Удаление мертвого кода (-dce)
  2. Распространение констант (-constprop)

---

## 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?

Граф потока управления (Control Flow Graph, CFG) — это ориентированный граф, в котором узлы представляют собой базовые блоки (последовательности инструкций без ветвлений), а рёбра указывают возможные переходы управления между ними. CFG помогает анализировать поведение программы, поскольку явно показывает, как управление передаётся между частями кода. Это важно для:
- Оптимизаций (например, удаление мёртвого кода),
- Анализа достижимости кода,
- Построения доминаторов и др.

---

## 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?

В LLVM IR арифметические операции выражаются как трёхадресные инструкции. Каждая операция имеет вид:  
`<результат> = <операция> <тип> <операнд1>, <операнд2>`  
Примеры:
- Сложение: `%sum = add i32 %a, %b`
- Умножение: `%product = mul i32 %x, %y`

Все операции строго типизированы, что делает IR пригодным для анализа и трансформаций.

---

## 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?

Функции в LLVM IR являются изолированными единицами с чётко определёнными входами и выходами. Это упрощает:
- Локальный анализ (например, обнаружение неиспользуемых переменных),
- Применение оптимизаций (например, инлайнинг, DCE),
- Повторное использование и компоновку,
- Возможность параллельного анализа и компиляции.

---

## 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

LLVM применяет **инлайнинг**: короткая функция, вызываемая один раз, скорее всего будет встроена в место вызова. Это позволяет:
- Избежать накладных расходов на вызов,
- Раскрыть больше возможностей для последующих оптимизаций (например, константная свёртка).

---

## 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

Использование промежуточного представления (IR) и CFG даёт несколько ключевых преимуществ:
- **Упрощённая структура**: IR лишён синтаксической сложности языков высокого уровня, как C.
- **Явная типизация и контроль потока**: облегчает анализ и трансформации.
- **Унификация**: единый формат позволяет применять одни и те же оптимизации ко всем языкам, транслируемым в LLVM IR.
- **Гибкость**: IR легко преобразуется и анализируется, что делает возможными агрессивные оптимизации, сложные на уровне исходного кода.


